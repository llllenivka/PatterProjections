# Паттерны проектирования

Паттерны проектирования - способ построения программного кода.

## Cодержание

1. [Классификация паттернов](#классификация-паттернов)
2. [Пораждающие](#пораждающие)
    - [Фабричный метод](#фабричный-метод)
    - [Абстрактная фабрика](#абстрактная-фабрика)


## Классификация паттернов

- __Пораждающие__ - гибкое управление процессом создания объектов.
- __Структурные__
- __Поведенческие__

## Пораждающие

```
Это группа паттернов, которые отвечают за создание объектов, позволяя гибко управлять процессом их создания. Эти паттерны помогают создавать объекты таким образом, чтобы они были легко заменяемы и масштабируемы, а также способствуют снижению зависимости между клиентом и создаваемыми объектами.
```
### Фабричный метод

![FactoryMethodDiagram](image/factorymethod.png)

__Фабричный метод (Factory Method)__ — это порождающий паттерн проектирования, который позволяет создавать объекты, не уточняя конкретный класс объекта, который будет создан. Вместо того чтобы напрямую создавать экземпляр класса, фабричный метод делегирует создание объекта в подклассы, что позволяет изменять тип создаваемого объекта без изменения кода, использующего этот объект.


#### Основная идея

Цель паттерна — предоставить интерфейс для создания объектов, но делегировать этот процесс подклассам. Это позволяет использовать одну и ту же базовую структуру, но иметь возможность создавать различные типы объектов, не изменяя клиентский код.

#### Структура

Creator (Создатель) — это абстрактный класс или интерфейс, который объявляет фабричный метод. Создатель может также реализовать общий функционал для работы с объектами.

ConcreteCreator (Конкретный создатель) — это класс, который реализует фабричный метод и создает конкретный объект.

Product (Продукт) — это абстракция, которая описывает объекты, создаваемые фабричным методом.

ConcreteProduct (Конкретный продукт) — это конкретная реализация продукта, который создается с помощью фабричного метода.



---

#### Задание

Разработка системы для создания различных типов уведомлений

__Условие задачи__: 

Представьте, что вам нужно разработать систему для отправки уведомлений пользователям. Уведомления могут быть разных типов, например, Email, SMS и Push-уведомление.

1. Создайте интерфейс INotification, который будет определять метод Send(), отвечающий за отправку уведомлений.

2. Реализуйте конкретные классы уведомлений:
    - EmailNotification
    - SMSNotification
    - PushNotification

3. Каждый класс должен реализовывать метод Send(), выводящий сообщение в консоль о том, что уведомление отправлено через соответствующий канал.

4. Создайте абстрактный класс NotificationCreator с абстрактным методом CreateNotification(), который будет отвечать за создание уведомлений.

5. Реализуйте конкретные создатели:
    - EmailNotificationCreator
    - SMSNotificationCreator
    - PushNotificationCreator

6. В клиентском коде используйте создателя для создания и отправки уведомлений, не зная, какой конкретный тип уведомления был создан.

__Структура классов__:

- INotification — интерфейс для уведомлений.
- ConcreteNotification (например, EmailNotification) — конкретные типы уведомлений.
- NotificationCreator — абстрактный создатель.
- ConcreteCreator (например, EmailNotificationCreator) — конкретные создатели для каждого типа уведомлений.

__Дополнительные вопросы__:

1. Почему использование фабричного метода помогает избежать жесткой привязки к конкретным типам объектов?
2. Какую роль играет абстракция в паттерне Фабричный метод? Чем она помогает улучшить гибкость системы?

__Пример ожидаемого вывода__:

При создании уведомления через EmailNotificationCreator будет выведено:

```
Отправка Email уведомления...
```

При создании уведомления через SMSNotificationCreator будет выведено:

```
Отправка SMS уведомления...
```
---
### Абстрактная фабрика

![AbstractFactoryDiagram](image/abstractfactory.png)

__Абстрактная фабрика__ — это порождающий паттерн проектирования, который предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов.

В отличие от Фабричного метода, который создает один тип объекта, Абстрактная фабрика создает целые семейства объектов, которые могут быть связаны друг с другом. Основная цель — обеспечить гибкость и независимость от конкретных реализаций.

__Структура__

Абстрактная фабрика (AbstractFactory) — определяет интерфейс для создания семейств объектов.

Конкретная фабрика (ConcreteFactory) — реализует интерфейс и создает конкретные объекты.

Абстрактный продукт (AbstractProduct) — определяет интерфейс для группы продуктов.

Конкретный продукт (ConcreteProduct) — конкретная реализация продукта.

Клиент (Client) — использует фабрику для создания продуктов, но не знает о конкретных классах продуктов.

__Пример кода на C#__

1. Интерфейсы продуктов
```csharp
public interface IButton
{
    void Render();
}

public interface ICheckbox
{
    void Render();
}
```
2. Конкретные продукты
```csharp
public class WindowsButton : IButton
{
    public void Render()
    {
        Console.WriteLine("Рендеринг кнопки в стиле Windows");
    }
}

public class MacOSButton : IButton
{
    public void Render()
    {
        Console.WriteLine("Рендеринг кнопки в стиле MacOS");
    }
}

public class WindowsCheckbox : ICheckbox
{
    public void Render()
    {
        Console.WriteLine("Рендеринг чекбокса в стиле Windows");
    }
}

public class MacOSCheckbox : ICheckbox
{
    public void Render()
    {
        Console.WriteLine("Рендеринг чекбокса в стиле MacOS");
    }
}
```

3. Абстрактная фабрика
```csharp
public interface IUIFactory
{
    IButton CreateButton();
    ICheckbox CreateCheckbox();
}
```

4. Конкретные фабрики
```csharp
public class WindowsFactory : IUIFactory
{
    public IButton CreateButton()
    {
        return new WindowsButton();
    }

    public ICheckbox CreateCheckbox()
    {
        return new WindowsCheckbox();
    }
}

public class MacOSFactory : IUIFactory
{
    public IButton CreateButton()
    {
        return new MacOSButton();
    }

    public ICheckbox CreateCheckbox()
    {
        return new MacOSCheckbox();
    }
}
```

5. Клиентский код
```csharp
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Выберите платформу (1 - Windows, 2 - MacOS):");
        string? input = Console.ReadLine();

        IUIFactory factory = input switch
        {
            "1" => new WindowsFactory(),
            "2" => new MacOSFactory(),
            _ => throw new Exception("Неверный ввод")
        };

        // Клиент использует фабрику для создания продуктов
        IButton button = factory.CreateButton();
        ICheckbox checkbox = factory.CreateCheckbox();

        button.Render();
        checkbox.Render();
    }
}
```

__Что происходит в клиентском коде?__

Пользователь выбирает платформу (Windows или MacOS).
В зависимости от выбора, создается WindowsFactory или MacOSFactory.
Используя фабрику, клиент создает кнопку и чекбокс.
Клиентский код не знает, какие конкретные классы создаются. Он просто вызывает методы CreateButton() и CreateCheckbox().

---
__Задание:__

Задача: Создать фабрику для "виртуальной кухни"

- Вы должны создать систему виртуальной кухни, где шеф-повар готовит разные блюда для завтрака и обеда.
- У каждой кухни (например, Итальянская кухня и Японская кухня) есть свои Блюда на завтрак и Блюда на обед.

__Условия__

1. Абстрактные продукты:
    - IBreakfast (Завтрак)
    - ILunch (Обед)

2. Конкретные продукты:
    - Итальянский завтрак: Капучино
    - Итальянский обед: Паста
    - Японский завтрак: Мисо-суп
    - Японский обед: Суши

4. Абстрактная фабрика:
    - ICuisineFactory с методами CreateBreakfast() и CreateLunch()

5. Конкретные фабрики:
    - ItalianCuisineFactory — создает Капучино и Пасту
    - JapaneseCuisineFactory — создает Мисо-суп и Суши

6. Клиент:
    - Спрашивает у пользователя, какую кухню выбрать: Итальянскую или Японскую.
    - Готовит завтрак и обед в зависимости от выбранной кухни.
    - Отображает, что было приготовлено.

__Пример ожидаемого вывода:__

```markdown
Выберите кухню (1 - Итальянская, 2 - Японская):
> 1
Приготовление завтрака: Капучино
Приготовление обеда: Паста
```

__Подсказки:__

- Клиентский код не должен зависеть от конкретных фабрик.
- Используйте switch-case для выбора кухни.

__Бонус-задача:__

- Добавьте третью кухню (Французскую) с её блюдами. Например, Круассан (завтрак) и Рататуй (обед).
---